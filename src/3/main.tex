\chapter{Vytvorenie knižnice na~nahrávanie obrázkov}
\section{Ciele}

Ciele, ktoré sme stanovili pri~vytváraní knižnice majú za~cieľ maximalizovať pohodlie užívateľa, minimalizovať zaťaženie pre~tvorcov stránky a~mala byť prístupná pre~čo najširšie publikum. Preto sme stanovili, že knižnica by mala:

\begin{itemize}
	\item byť nezávislá od~knižníc/frameworkov tretích strán, napr. \emph{jQuery},
	\item podporovať nahrávanie či už zvolením obrázka cez~modálne okno alebo aj technológiou \emph{Drag&Drop}, 
	\item byť jednuduchá na~implementovanie
	\item byť dobre rozšíriteľná o~nové funkcie
	\item podporovať nahrávanie bez~refreshu
	\item podporovať mobilné zariadenia
	\item podporovať nahrávanie viacerých obrázkov
	\item byť dobre zdokumentovaná
\end{itemize}


\section{Riešenie}
\subsection{Predstavenie}
Najskôr sme plánovali využiť \emph{jQuery}, ale kvôli splneniu prvého cieľa (byť nezávislí od~knižníc/frameworkov tretích strán) sme sa rozhodli využiť \emph{Custom Element}. Vytvorili sme jeden, ktorý slúži na~úpravu obrázka \emph{<x-cupe>} a~jeden na~podporu multiuploadu - \emph{<x-cupe-gallery>}. Oba vychádzajú z~rovnakého HTML, pričom \emph{<x-cupe-gallery>} interne využíva \emph{<x-cupe>}, preto sa ďalej v~tejto kapitole zameráme na~element \emph{<x-cupe>}. Nahrávanie viacerých obrázkov je bližšie popísané v~kapitole 3.5.


Scénar nahrávania môže vyzerať takto:
\begin{enumerate}
	\item Užívateľ buď pomocou Drag&Drop nahraje obrázok alebo klikne na~element a~následne si z~modálneho okna zvolí obrázok
	\item Obrázok sa zmenší, oreže a~zobrazí
	\item Pokiaľ užívateľ nie je spokojný s~obrázokom, pokračuje prvým bodom
	\item Pokiaľ užívateľ nie je spokojný s~orezaním, držaním myšy posúva obrázok, dokým nie je spokojný
	\item Keď je užívateľ spokojný s~obrázkom aj jeho orezaním odošle formulár, a~až vtedy sa zmenšaná a~orezaná verzia nahraje na~server
\end{enumerate}

Hoc sa v~scenári spomína klikanie, knižnica podporuje aj dotykové zariadenia a~teda všetky úkony je možné vykonať dotykom. Interne oba elementy využívajú nasledujúce HTML:

\begin{lstlisting}[language=HTML]
<canvas></canvas>
<input type="file" style="display: none">
<input type="text" style="display: none">
\end{lstlisting}

Element \emph{<canvas>} sa stará o~zobrazenie obrázka, a~na prácu s~ním sme vytvorili pomocnú triedu \emph{XCupeCanvasElement}, pomocou ktorej vieme rýchlo zmeniť rozmery. Keď užívateľ klikne na~\emph{<x-cupe>}, element deleguje klik na~\emph{<input type="file"\textgreater}, čo spôsobí, že sa otvorí modálne okno a~užívateľ si môže zvoliť obrázok. Pre~zjednodušenie práce s~ním sme vytvorili triedu \emph{XCupeInputFileElement}. Do~\emph{<input type="text"\textgreater} sa vloží textová reprezentácia obrázka, čo umožňuje jeho odoslanie cez~POST. Opäť, aj pre~tento element sme vytvorili pomocnú triedu \emph{XCupeInputFileElement}. Detailné popísanie, ako knižnica funguje vrátane využitia jednotlivých elementov je ďalej popísané v~sekcií 3.4.

\subsection{Inštalácia}

Použitie \emph{Custom Elementu} nám umožnuje skutočne jednoduchý spôsob inštalácie, kde sa najskôr načítajú zdrojové súbory knižnice:
\begin{lstlisting}
<link rel="import" href="dist/x-cupe.html">
\end{lstlisting}

Následne stačí už len na~príslušnom mieste v~kóde vytvoriť element:
\begin{lstlisting}
<x-cupe></x-cupe>
\end{lstlisting}

V prípade nahrávania viacerých obrázkov:
\begin{lstlisting}
<x-cupe-gallery></x-cupe-gallery>
\end{lstlisting}

\begin{figure}[!hb]
	\centering
	\begin{tikzpicture}[node distance=.8cm, start chain=going below,]
		\node[punktchain] (file-read) {Prečítanie súboru};
		
			\begin{scope}[start branch=clicking,
			every join/.style={->, thick, shorten <=1pt}, ]
				\node[punktchain, on chain=going above left, join=by {<-}, xshift=2cm]
					(modal) {Výber obrázka z~modálneho okna};
					
				\node[punktchain, on chain=going above, join=by {<-}] (x-cupe-click) {Kliknutie na~\emph{<x-cupe>}};
			\end{scope}
			
			\begin{scope}[start branch=dragging,
			every join/.style={->, thick, shorten <=1pt}, ]
				\node[punktchain, on chain=going above right, join=by {<-}, xshift=-2cm]
					(drag-n-drop) {Nahranie obrázka pomocou drag\&drop};
			\end{scope}
		\node[punktchain, join, on chain=going below] (resizing) {Zmenšenie};
		\node[punktchain, join, on chain=going below] (cropping) {Výpočet orezania};
		\node[punktchain, join, on chain=going below] (drawing) {Vykreslenie };
		
			\begin{scope}[start branch=mousemove,
			every join/.style={<-, thick, shorten <=1pt}, bend right=15]
				\node[punktchain, on chain=going above right, join=by {->}, yshift=-0.8cm]
					(changing-crop) {Úprava orezania posúvaním}
					edge[punktchain, ->, bend right=15] (cropping);
			\end{scope}
		\node[punktchain, join, on chain=going below] (form-a) {Uloženie a~odoslanie};
	\end{tikzpicture}
	
	\caption{Schéma nahrávania obrázka pomocou \emph{<x-cupe>} elementu}
\end{figure}

\section{Použité technológie, služby a~postupy}
\subsection{Custom Element a~ShadowDOM}
\subsection{Canvas}

Canvas je nový tág \emph{HTML5}, ktorý umožňuje pomocou JavaScriptu vykresľovať grafy, úpravovať fotografií, animovať a~dokonca aj spracovať videa. Využíva ho aj \emph{WebGL} na~hardvérovo akcelerovanú 3D grafiku na~webe\cite{MDN_Canvas}.

V našej práci ho využívame na~zobrazovanie obrázka. Samotná knižnica už obsahuje potrebné nástroje na~vkladanie a~zmenšovanie obrázka, čo nám uľahčuje prácu a~zároveň nám \emph{<canvas>} umožňuje prístup k~jednotlivým pixelom, čo odcenia najm tvorcovia pokročilých rozšírení (napr. detekovať nevyužívanú plochu obrázka alebo prevod do~čierno-bielej verzie). Keď užívateľ presúva obrázok, kvôli orezaniu, prekresľujeme daný výrez do~\emph{<canvas>} pomocou \emph{requestAnimationFrame}\cite{MDN_RequestAnimationFrame}, pre~maximálnu plynulosť.

\subsection{Drag&Drop}
\subsection{File Reader}

File Reader umožňuje čítať obsah súborov vo webovom prostredí. Tie môžu byť načítané buď pomocou tágu \emph{<input>} alebo pomocou \emph{Drag&Drop} (viď. 3.3.3)\cite{MDN_FileReader}\footnote{Citovaný MDN udáva ešte aj HTMLCanvasElement.mozGetAsFile(), ktorý je neštandardizovaný a~v dobe písanie tejto práce podporovaný iba prehliadačom Firefox}.

Použili sme ho práve pre~prečítanie zvolených súborov, ktoré sme následne zobrazili v~\emph{<canvas>} (viď 3.3.2).

\subsection{Promise}

Promise je objekt určený pre~asynchrónne výpočty a~výpočty naplánované na~neskôr (napríklad cez~\emph{setTimeout} alebo \emph{setInterval}). Nevracia priamo metódu, ale vracia "prísľub", že niekedy v~budúcnosti hodnota bude dostupná\cite{MDN_Promise}. V~silno asynchrónnej aplikácií zabraňuje tzv. "callback hell", kde množstvo callbackov bráni zrozumiteľnosti a~ladeniu kódu.

Promise sme používame miesto predávania callbackov, predovšetkým pri~čítaní užívateľovho obrázku.

\subsection{TypeScript}

TypeScript je typová nadstavba JavaScriptu, ktorá sa prekladá do~JavaScriptu. Tým, že sa rýchlo vyvíja okrem~typovosti prináša aj funkcie \emph{ECMAScript 2015 (ES6)}, čo umožňuje progrmátorom používať funkcie, ktoré v~čase písania tejto bakalárskej práce ešte nie sú implementované v~prehliadačoch.

Naša knižnica využíva TypeScript pretože umožňuje rýchlejšie odhaľovať chyby, vedie k~písaniu rozhraní, čo môže značne pomôcť tvorcom rozšírení a~tiež kvôli podpore \emph{ECMAScript 2015}. Navyše jeho vlastnosť, že sa prekladá do~JavaScriptu nijak neobmedzuje tvorcov rozšírení alebo jeho celkové použitie.

\subsection{Mocha}
\subsection{GitHub}

Počas tvorby sme používali Git a~výsledok našej práce sme uverejnili v~službe GitHub - webovej službe na~správu Git repozitárov. // TODO: pokračovať; prečo sme to spravili?


\section{Postup nahrávania a~nastavenia}

V tejto sekcií sa budeme samotnému procesu nahrávania obrázku, od~jeho zvolenia, úpravy po~odoslanie na~server.


\subsection{Inicializácia knižnice}
\subsection{Zvolenie obrázka}

Užívateľ môže obrázok zvoliť dvoma spôsobmi - výberom z~modálneho okna alebo pomocou \emph{Drag&Drop}. V~prípade nahrávania obrázka cez~modálne okno, užívateľ musí kliknúť na~\emph{<x-cupe>} element, do~ktorého chce obrázok nahrať. Interne sa tento klik prevedie na~\emph{<input type="file"\textgreater} a~to spôsobí otvorenie modálneho okna. Po~tom, čo si užívateľ zvolí obrázok, je tento súbor pomocou \emph{File Reader} (viď. 3.3.4) prečítaný a~pripravený na~ďalšie spracovanie. V~prípade, že chceme tento spôsob nahrávania zakázať, stačí nastaviť atribút \emph{allow-select} na~hodnotu \emph{false}.

V prípade použitia Drag&Drop a~teda označenie obrázka, jeho presunutie ponad cieľový element a~následne pustenie myši/oddialenie prsta od~dotykovej plochy, je postup podobný. Element (<x-cupe>) vie pomocou zachytenia udalosti \emph{drop} zachytiť presúvaný obrázok a~dalej ho rovnako ako pri~modálnom okne pomocou \emph{File Reader} prečítať. Ak chceme tento spôsob zakázať, je potrebné nastaviť atribút \emph{allow-drop} na~hodnotu \emph{false}.

\subsection{Zmenšenie a~orezanie}

Po zvolení obrázka spravidla prebieha jeho zmenšenie a~orezanie. Pre~túto činnosť je potrebné vedieť rozmery nahrávaného obrázka a~tiež rozmery výsledného obrázka, pričom sú implementované tieto scenáre:

\begin{itemize}
	\item[Nahrávaný obrázok je väčší a~mal by sa zmenšiť; orezávanie je zapnuté] \hfill \\
	Očakávame, že práve tento scénar bude najvyužívanejší. V~tomto scenári sa obrázok pomerne zmenší tak, aby pomerne kratšia strana nahrávaného obrázka bola zhodná s~príšlusnou stranou finálneho obrázka. To je z~toho dôvodu, aby užívateľ mohol hýbať obrázkom v~ose, ktorá je pomerne dlhšia (a teda v~tej, v~ktorej má posúvanie zmysel). Pre~lepšie porozumienie uvádzame aj obrázok. // TODO obrázok
	\item[Nahrávaný obrázok je väčší a~mal by sa zmenšiť; orezávanie je vypnuté] \hfill \\
	V~tomto prípade sa snažíme vložiť celý nahrávaný obrázok do~finálneho obrázka. Dosiahneme to pomerným zmenšením obrázka tak, aby pomerne dlhšia strana bola zhodná s~príslušnou stranou finálneho obrázka.
	\item[Nahrávaný obrázok je menší a~mal by si zväčšiť; orezávanie je zapnuté] \hfill \\
	Cieľom našej knižnice je, aby spravca stránky vždy dostal z~prehliadača taký obrázok, aký požaduje. Nemusí potom upravovať obrázok na~serveri. To však znamená, že môže nastať prípad, že užívateľ zvolí menší nahrávaný obrázok, než je požadovaný finálny obrázok. V~tom prípade prebieha spracovanie obrazu rovnako, ako v~prvom scenári, len miesto zmenšovania sa obrázok zväčšuje.
	\item[Nahrávaný obrázok je menší a~mal si zväčšiť; orezávanie je vypnuté] \hfill \\
	Postupujeme rovnako ako v~prípade s~väčším obrázkom. Miesto zmenšovania však obrázok zväčšujeme.
	\item[Finálny obrázok má len jeden fixný rozmer] \hfill \\
	Tento scenár je vhodný, ak vytvárame napr. obrázkove galérie, pričom chceme, aby obrázky mali pevnú šírku a~ľubovoľne dlhú dĺžku. Ak chceme variabilnú šírku, je potrebné nastaviť atribút \emph{width} elementu \emph{<x-cupe>} na~hodnotu \emph{-1}. V~prípade, že chceme variabilnú dĺžku, je potrebné obdobne nastaviť parameter \emph{height} na~hodnotu \emph{-1}. V~tomto scenári sa obrázok pomerne zmenší podľa fixnej príslušnej strany finálneho obrázka. Druhá strana finálneho obrázka sa nastaví pomerne zmenšej dĺžke finálneho obrázka. V~tomto scenári nie je možné obrázok orezávať.
	\item[Finálny obrázok nemá fixný rozmer] \hfill \\
	Tento scénar je vhodný, ak chceme aby užívatelia mohli zaslať obrázok v~ľubovoľných rozmeroch a~zároveň ho pred~odoslaním mohli vidieť. Finálny obrázok bude mať rozmery nahrávaného obrázka a~ten teda nie je zmenšovaný ani orezávaný. Pre~vytvorenie tejto situácie treba nastaviť aj atribút \emph{width} aj atribút \emph{height} na~hodnotu \emph{-1}.
	
\end{itemize}


Obrázok sa orezáva posúvaním obrázka (viď 3.4.4) a~základným nastavením je orezanie na~stred. To sa dá zmeniť atribútom \emph{align}, pričom valídne hodnoty pozostávajú z~kombinácie slov \emph{left}, \emph{right}, \emph{top}, \emph{bottom} a~\emph{center}, napríklad: \emph{<x-cupe align="left bottom"\textgreater}. Pri~zadaní iba jednej osi pre~zarovnanie sa automaticky predpokladá, že druhá sa má zarovnať na~stred. Orezanie sa dá úplne vypnúť a~to nastavením atribútu \emph{crop} na~hodnotu \emph{false}. Vnútorne knižnica pracuje tak, že sa textové hodnoty prerátajú na~odsadenie obrázku zľava a~zhora, ale obrázok sa nijako nemodifikuje. To nastáva až pri~vykreslení.

Takisto sme si všimli, že ak zmenšíme veľmi veľký obrázok, jeho kvalita je nízka. Oproti pôvodnému obrázku je zdanlivo ostrejší a~to je spôsobené nevyhovujúcim spôsobom prekresľovania obrázka, tzv. \emph{downsampling}-om. Problém je, že prehliadač musí z~plochy napríklad 4x4 pixely vytvoriť iba jeden pixel a~aby to spravil najrychlejšie, jeden z~nich vyberie, pričom sa neberie do~úvahy kontext. Preto sme aplikovali jednoduchý algoritmus, ktorý obrázok zmenší postupne. Počet prekreslení je možné nastaviť atribútom \emph{quality} a~jeho predvolená hodnota je 3. Čím vyššia táto hodnota je, tým dlhšie trvá proces od~zvolenia obrázka po~jeho vykreslenie. Keď je táto hodnota príliš nízka (napríklad 1), tak je slabšia kvalita. Zmenšený obrázok sa uloží, aby pri~jeho ďalšej manipulácií ho nebolo potrebné opäť zmenšovať.

\subsection{Posúvanie obrázka}

Pokiaľ je povolené orezanie obrázka, je možné toto orezanie meniť posúvaním obrázka. Aby sme odlíšili kliknutie, kedy má vyskočiť modálne okno s~možnoťou výberu obrázka a~samotné posúvanie, nastavili sme limit, počas ktorého musí užívateľ držať myš stlačenú na~100ms. Rovnaký limit platí aj pre~dotykové zariadenia. Po~spustení udalosti presúvania sa vyrátava súčasná pozícia myšy a~porovnáva sa s~pozíciou na~ktorej začalo presúvanie. Rozdielom týchto hodnôt získavame informáciu o~tom, ako máme posunúť obrázok. Tento rozdiel sa následne priráta k~orezaniu obrázka. Nakoniec už zmenšený obrázok s~novým nastavením orezania vykreslíme s~využitím \emph{requestAnimationFrame}. Posúvanie obrázka sa dá vypnúť nastavím atribútu \emph{allow_move} na~hodnotu \emph{false}

// TODO: Prečo neprebieha ukladanie ak zvyčajne prebieha, ak prebieha?

\subsection{Odoslanie obrázka}

\section{Nahrávanie viacerých obrázkov}

Nahrávanie viacerých obrázkov je možné pomocou párového tágu \emph{<x-cupe-gallery>}. Ten interne využíva elementy \emph{<x-cupe>}, ktoré vytvára vždy pri~zvolení nového obrázka, či už pomocou modálneho okna alebo pomocou \emph{Drag&Drop}. Element \emph{<x-cupe-gallery>} podporuje všetky atribúty ako \emph{<x-cupe>}, avšak pri~ich zmene sa táto zmena pošle všetkým \emph{x-cupe} elementom. Výnimkou sú atribúty \emph{allow-drop} a~\emph{allow-select}, ktoré sa aplikujú len pre~\emph{<x-cupe-gallery>} a~v \emph{<x-cupe>} sú vypnuté.


\section{Rozšíriteľnosť}

Nakoľko naša knižnica používa na~spracovanie a~zobrazovanie obrazu tág \emph{<canvas>}, využíva a~aj poskytuje možnosť pracovať s~obrazom na~úrovni jednotlivých pixelov. To umožňuje vytváranie pokročilých rozšírení, ktoré napríklad dokážu zmeniť farebné otiene, využívať detekciu hrán, rozpoznávanie tvárí a~podobne.

\subsection{Systém rozšírení}

Predstavme si dve rozšírenia - "zoom" (rozšírenie umožňujúce zväčšovať a~zmenšovať obraz) a~"black\&white" (rozšírenie, ktoré prevedie obraz do~čierno-bielej škály). Chceli sme, aby tvorca stránky vedel stanoviť, ktoré \emph{<x-cupe>} elementy budú používať "black\&white", a~ktoré nie. Tiež sme chceli, aby vedel nastaviť rozšírenie "zoom" pre~všetky \emph{<x-cupe>} elementy. \textbf{Naším cieľom teda bolo, aby rozšírenie bolo možné aplikovať aj pre~jednotlivé \emph(<x-cupe>) elementy, ale aj univerzálne - pre~všetky \emph(<x-cupe>) elementy}. Naším ďalším cieľom bolo, aby \textbf{rozšírenia bolo možné kombinovať}, a~teda aby tvorca stránky vedel nastaviť obe rozšírenia - "zoom" aj "black\&white" na~rovnaký \emph{<x-cupe>} element. Naším posledným cieľom bolo, aby boli rozšírenia nezávislé moduly - samostatné súbory, ktoré o~sebe nevedia (resp. nemusia vedieť).

Zhodnotili sme existujúce riešenia a~rozhodli sme sa, že rozšírenia budú funkcie, ktoré budú upravovať metódy našej knižnice. Tým dosiahneme "cibuľový efekt".

\subsection{Cibuľový efekt}

Pre lepšie vysvetlenie uvádzame vzorku kódu so~vzorového rozšírenia "zoom" (viď. 3.6.4), na~ktorom následne vysvetlíme, "cibuľový efekt" a~jeho výhody.

\begin{lstlisting}[label=vytvaranie-cibuloveho-efektu,caption=Vytváranie cibuľového efektu]
var self = this;
var originalRnDImg = controller.readAndDrawImage; // (A)
controller.readAndDrawImage = function() // (B)
{
    return originalRnDImg.apply( self, arguments ) // (C)
    .then( function()
    {
        // ... (D)
    }
}
\end{lstlisting}

\begin{description}
	\item [(A)] Do~premennej \emph{originalRnDImg} uložíme pôvodnú metódu \emph{readAndDrawImage} \emph{XCupeController} triedy. 
	\item [(B)] Prepíšeme pôvodnú metódu \emph{readAndDrawImage} novou funkciou, ktorá
	\item [(C)] spustí pôvodnú metódu, a~keď tá prebehne úspešne, tak
	\item [(D)] vykoná doplňujúci kód.
\end{description}

Je potrebné si uvedomiť, že metóda \emph{readAndDrawImage} ostáva zmenená a~keď k~nej bude pristupovať ďalšie rozšírenie (napr. "black\&white" popísaný v~3.6.1), opäť pridá ďalšiu vrstvu. Následne keď bude metódu volať \emph{XCupeController}, zavolá modifikáciu z~"black\&white", ktorá zavolá modifikáciu z~rozšírenia "zoom", ktoré zavolá pôvodnú metódu.


Tým sme dosiahli, že:

\begin{enumerate}
	\item Je možné aplikovať súčasne niekoľko rozšírení na~jeden \emph{<x-cupe>} element.
	\item Jednotlivé rozšírenia o~sebe nevedia. Všetky pristupujú (v prípade ukážky) k~\emph{XCupeController}. 
\end{enumerate}


\subsection{Aplikovanie rozšírenia}

Rozšírenie je funkcia, pričom odporúčame, aby vždy dávala možnosť aplikovať rozšírenie zvlášť na~jednotlivé prvky ale tiež aj na~všetky prvky. Vo vzorovom rozšírení "zoom" (viď. 3.6.4) sme to dosiahli prvým parametrom, ktorý ak je prázdny tak sa aplikuje rozšírenie na~triedu XCupeController. V~prípade, že prázdny nie je, predpokladáme, že obsahuje odkaz na~už vytvorený element a~teda rozšírenie aplikujeme na~ňom. Pre~plné porozumenie uvádzame príklad:

\begin{lstlisting}[language=JavaScript]
// Aplikuje zoom pre~všetky XCupe elementy
makeCupeZoomable();

// Aplikuje zoom pre~vybraný XCupe element
var cupeElement = new HTMLXCupeElement();
makeCupeZoomable( cupeElement );
\end{lstlisting}

\subsection{Vzorové rozšírenie}

Praktická časť tejto práce, v~zložke \emph{plugins} obsahuje vzorové rozšírenie \emph{zoom}. Toto rozšírenie má za~úlohu umožniť užívateľom zväčšovať a~zmenšovať obrázok pred~odoslaním.

Keď užívateľ obrázok vloží, vyráta sa pomer medzi~zobrazovacou plochou a~skutočnou veľkosťou obrázka a~vyráta sa maximálne oddialenie. Za~najnižšie oddialenie (alebo maximálne priblíženie) je určená hodnota, kde jeden pixel nahrávaného obrázka zodpovedá jednému zobrazenému pixelu. Následné točenie stredným stlačídlom myši mení pomer, akým sa pôvodný obrázok zmenší predtým, než sa vykreslí.

\begin{figure}[!hb]
	\centering
	\begin{tikzpicture}

		\draw (0,0) rectangle (-5,-3) node[pos=.5] {\emph{<x-cupe>} element};
		\draw (4,0) rectangle (-5,-5) node[pos=.85, xshift=3.2cm] {Nahraný obrázok};

		\draw[tuborg, decoration={brace}] let \p1=(0.1,-0.1), \p2=(0.1,-2.9) in ($(\x1, \y1)$) -- ($(\x2, \y2)$) node[tubnode] {300px};
		\draw[tuborg, decoration={brace}] let \p1=(-0.1,-3.1), \p2=(-4.9,-3.1) in ($(\x1, \y1)$) -- ($(\x2, \y2)$) node[tubnode, below] {500px};

		\draw[tuborg, decoration={brace}] let \p1=(4.1, 0.1), \p2=(4.1, -4.9) in ($(\x1, \y1)$) -- ($(\x2, \y2)$) node[tubnode] {500px};
		\draw[tuborg, decoration={brace}] let \p1=(3.9,-5.1), \p2=(-4.9,-5.1) in ($(\x1, \y1)$) -- ($(\x2, \y2)$) node[tubnode, below] {900px};

	\end{tikzpicture}
	\caption{Nákres možného scenára nahrávaného obrázka}
\end{figure}

\section{Spracovanie obrázka na~PHP serveri}
\section{Dokumentácia}